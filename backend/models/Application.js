import mongoose from "mongoose";

const applicationSchema = new mongoose.Schema(
  {
    // Application Information
    applicationNumber: {
      type: String,
      required: false, // Will be generated by pre-save middleware
      unique: true,
      trim: true,
    },
    type: {
      type: String,
      enum: ["murabahah", "musharakah", "ijarah", "salam", "istisna"],
      required: [true, "Application type is required"],
    },
    title: {
      type: String,
      required: [true, "Application title is required"],
      trim: true,
      maxlength: [200, "Title cannot exceed 200 characters"],
    },

    // Parties Involved
    applicant: {
      type: mongoose.Schema.Types.ObjectId,
      refPath: "applicantType",
      required: [true, "Applicant is required"],
    },
    applicantType: {
      type: String,
      enum: ["Individual", "Business"],
      required: [true, "Applicant type is required"],
    },
    serviceProvider: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "ServiceProvider",
    },
    capitalProvider: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "CapitalProvider",
    },

    // Application Details
    details: {
      description: {
        type: String,
        required: [true, "Description is required"],
        trim: true,
        maxlength: [1000, "Description cannot exceed 1000 characters"],
      },
      amount: {
        type: Number,
        required: [true, "Amount is required"],
        min: [0, "Amount cannot be negative"],
      },
      currency: {
        type: String,
        default: "USD",
        enum: ["USD", "EUR", "GBP", "SAR", "AED"],
      },
      purpose: {
        type: String,
        required: [true, "Purpose is required"],
        trim: true,
      },
      timeline: {
        type: String,
        trim: true,
      },
    },

    // Vehicle Information (for Murabahah)
    vehicle: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Vehicle",
    },
    vehicleDetails: {
      make: String,
      model: String,
      year: Number,
      price: Number,
      downPayment: Number,
      financingAmount: Number,
      repaymentPeriod: Number, // months
    },

    // Application Status
    status: {
      type: String,
      enum: [
        "draft",
        "submitted",
        "under_review",
        "scholar_review",
        "financial_review",
        "approved",
        "rejected",
        "cancelled",
        "expired",
      ],
      default: "draft",
    },

    // Review Process
    reviews: {
      scholar: {
        reviewer: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Scholar",
        },
        status: {
          type: String,
          enum: [
            "pending",
            "in_progress",
            "approved",
            "rejected",
            "needs_revision",
          ],
          default: "pending",
        },
        reviewDate: Date,
        comments: String,
        proofOfFaith: {
          issued: {
            type: Boolean,
            default: false,
          },
          issuedAt: Date,
          certificateUrl: String,
        },
        priority: {
          type: String,
          enum: ["low", "medium", "high", "urgent"],
          default: "medium",
        },
      },
      financial: {
        reviewer: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "CapitalProvider",
        },
        status: {
          type: String,
          enum: [
            "pending",
            "in_progress",
            "approved",
            "rejected",
            "counter_offer",
          ],
          default: "pending",
        },
        reviewDate: Date,
        comments: String,
        offerLetter: {
          issued: {
            type: Boolean,
            default: false,
          },
          issuedAt: Date,
          documentUrl: String,
        },
        riskScore: {
          type: Number,
          min: [0, "Risk score cannot be negative"],
          max: [100, "Risk score cannot exceed 100"],
        },
        creditDecision: {
          type: String,
          enum: ["approve", "decline", "counter_offer"],
        },
      },
    },

    // AI Analysis
    aiAnalysis: {
      kycScore: {
        type: Number,
        min: [0, "KYC score cannot be negative"],
        max: [100, "KYC score cannot exceed 100"],
      },
      creditScore: {
        type: Number,
        min: [300, "Credit score cannot be below 300"],
        max: [850, "Credit score cannot exceed 850"],
      },
      riskAssessment: {
        level: {
          type: String,
          enum: ["low", "medium", "high", "very_high"],
        },
        score: {
          type: Number,
          min: [0, "Risk score cannot be negative"],
          max: [100, "Risk score cannot exceed 100"],
        },
        factors: [String],
        recommendations: [String],
      },
      shariahCompliance: {
        isCompliant: {
          type: Boolean,
          default: true,
        },
        complianceScore: {
          type: Number,
          min: [0, "Compliance score cannot be negative"],
          max: [100, "Compliance score cannot exceed 100"],
        },
        complianceNotes: [String],
        recommendations: [String],
      },
      analysisDate: {
        type: Date,
        default: Date.now,
      },
      analysisVersion: {
        type: String,
        default: "1.0",
      },
    },

    // Documents
    documents: [
      {
        type: {
          type: String,
          enum: [
            "application_form",
            "identity_document",
            "income_proof",
            "bank_statements",
            "vehicle_documents",
            "insurance",
            "other",
          ],
        },
        name: String,
        url: String,
        uploadedAt: {
          type: Date,
          default: Date.now,
        },
        uploadedBy: {
          type: mongoose.Schema.Types.ObjectId,
          refPath: "documents.uploadedByType",
        },
        uploadedByType: {
          type: String,
          enum: [
            "Individual",
            "Business",
            "ServiceProvider",
            "CapitalProvider",
            "Scholar",
            "Admin",
          ],
        },
        status: {
          type: String,
          enum: ["pending", "verified", "rejected"],
          default: "pending",
        },
      },
    ],

    // Communication
    messages: [
      {
        sender: {
          type: mongoose.Schema.Types.ObjectId,
          refPath: "messages.senderType",
        },
        senderType: {
          type: String,
          enum: [
            "Individual",
            "Business",
            "ServiceProvider",
            "CapitalProvider",
            "Scholar",
            "Admin",
          ],
        },
        message: String,
        timestamp: {
          type: Date,
          default: Date.now,
        },
        attachments: [String], // URLs to attached files
        isInternal: {
          type: Boolean,
          default: false,
        },
      },
    ],

    // Notifications
    notifications: [
      {
        type: {
          type: String,
          enum: [
            "status_update",
            "document_required",
            "review_assigned",
            "review_completed",
            "approval",
            "rejection",
            "reminder",
          ],
        },
        title: String,
        message: String,
        timestamp: {
          type: Date,
          default: Date.now,
        },
        isRead: {
          type: Boolean,
          default: false,
        },
        priority: {
          type: String,
          enum: ["low", "medium", "high", "urgent"],
          default: "medium",
        },
      },
    ],

    // Timeline
    timeline: [
      {
        status: String,
        description: String,
        timestamp: {
          type: Date,
          default: Date.now,
        },
        updatedBy: {
          type: mongoose.Schema.Types.ObjectId,
          refPath: "timeline.updatedByType",
        },
        updatedByType: {
          type: String,
          enum: [
            "Individual",
            "Business",
            "ServiceProvider",
            "CapitalProvider",
            "Scholar",
            "Admin",
            "System",
          ],
        },
      },
    ],

    // Expiration
    expiresAt: {
      type: Date,
    },

    // Metadata
    tags: [String],
    priority: {
      type: String,
      enum: ["low", "medium", "high", "urgent"],
      default: "medium",
    },
    source: {
      type: String,
      enum: ["web", "mobile", "api", "admin"],
      default: "web",
    },

    // Timestamps
    submittedAt: Date,
    lastActivity: Date,
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Indexes for better performance
applicationSchema.index({ applicationNumber: 1 });
applicationSchema.index({ applicant: 1, applicantType: 1 });
applicationSchema.index({ serviceProvider: 1 });
applicationSchema.index({ capitalProvider: 1 });
applicationSchema.index({ status: 1 });
applicationSchema.index({ type: 1 });
applicationSchema.index({ createdAt: -1 });
applicationSchema.index({ expiresAt: 1 });

// Virtual for formatted amount
applicationSchema.virtual("formattedAmount").get(function () {
  return `${this.details.currency} ${this.details.amount.toLocaleString()}`;
});

// Virtual for days until expiration
applicationSchema.virtual("daysUntilExpiration").get(function () {
  if (!this.expiresAt) return null;
  const now = new Date();
  const diffTime = this.expiresAt - now;
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
});

// Virtual for unread notifications count
applicationSchema.virtual("unreadNotificationsCount").get(function () {
  return this.notifications.filter((n) => !n.isRead).length;
});

// Pre-save middleware
applicationSchema.pre("save", function (next) {
  // Generate application number if not provided
  if (!this.applicationNumber) {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 5);
    this.applicationNumber = `APP-${timestamp}-${random}`.toUpperCase();
  }

  // Set expiration date if not provided (30 days from creation)
  if (!this.expiresAt) {
    this.expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
  }

  this.lastActivity = new Date();
  next();
});

// Static method to find active applications
applicationSchema.statics.findActive = function () {
  return this.find({
    status: {
      $in: ["submitted", "under_review", "scholar_review", "financial_review"],
    },
    expiresAt: { $gt: new Date() },
  });
};

// Static method to find expired applications
applicationSchema.statics.findExpired = function () {
  return this.find({
    status: {
      $in: ["submitted", "under_review", "scholar_review", "financial_review"],
    },
    expiresAt: { $lte: new Date() },
  });
};

// Static method to find by applicant
applicationSchema.statics.findByApplicant = function (
  applicantId,
  applicantType
) {
  return this.find({ applicant: applicantId, applicantType }).sort({
    createdAt: -1,
  });
};

// Instance method to submit application
applicationSchema.methods.submitApplication = function () {
  this.status = "submitted";
  this.submittedAt = new Date();

  // Add to timeline
  this.timeline.push({
    status: "submitted",
    description: "Application submitted for review",
    updatedByType: "System",
  });

  // Add notification
  this.notifications.push({
    type: "status_update",
    title: "Application Submitted",
    message: "Your application has been submitted and is under review",
    priority: "medium",
  });

  return this.save();
};

// Instance method to assign to scholar
applicationSchema.methods.assignToScholar = function (scholarId) {
  this.status = "scholar_review";
  this.reviews.scholar.reviewer = scholarId;
  this.reviews.scholar.status = "in_progress";

  // Add to timeline
  this.timeline.push({
    status: "scholar_review",
    description: "Application assigned to scholar for review",
    updatedByType: "System",
  });

  // Add notification
  this.notifications.push({
    type: "review_assigned",
    title: "Scholar Review Assigned",
    message:
      "Your application has been assigned to a scholar for Shariah compliance review",
    priority: "high",
  });

  return this.save();
};

// Instance method to assign to capital provider
applicationSchema.methods.assignToCapitalProvider = function (
  capitalProviderId
) {
  this.status = "financial_review";
  this.reviews.financial.reviewer = capitalProviderId;
  this.reviews.financial.status = "in_progress";

  // Add to timeline
  this.timeline.push({
    status: "financial_review",
    description:
      "Application assigned to capital provider for financial review",
    updatedByType: "System",
  });

  // Add notification
  this.notifications.push({
    type: "review_assigned",
    title: "Financial Review Assigned",
    message:
      "Your application has been assigned to a capital provider for financial review",
    priority: "high",
  });

  return this.save();
};

// Instance method to add message
applicationSchema.methods.addMessage = function (
  senderId,
  senderType,
  message,
  attachments = [],
  isInternal = false
) {
  this.messages.push({
    sender: senderId,
    senderType,
    message,
    attachments,
    isInternal,
    timestamp: new Date(),
  });

  return this.save();
};

// Instance method to add notification
applicationSchema.methods.addNotification = function (
  type,
  title,
  message,
  priority = "medium"
) {
  this.notifications.push({
    type,
    title,
    message,
    priority,
    timestamp: new Date(),
  });

  return this.save();
};

// Instance method to update status
applicationSchema.methods.updateStatus = function (
  newStatus,
  updatedBy,
  updatedByType,
  description
) {
  this.status = newStatus;

  // Add to timeline
  this.timeline.push({
    status: newStatus,
    description: description || `Status updated to ${newStatus}`,
    updatedBy,
    updatedByType,
  });

  // Add notification
  this.notifications.push({
    type: "status_update",
    title: "Status Updated",
    message: `Your application status has been updated to ${newStatus}`,
    priority: "medium",
  });

  return this.save();
};

export default mongoose.model("Application", applicationSchema);
