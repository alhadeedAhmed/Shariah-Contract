import mongoose from "mongoose";

const quoteSchema = new mongoose.Schema(
  {
    // Quote Information
    quoteNumber: {
      type: String,
      required: false, // Will be generated by pre-save middleware
      unique: true,
      trim: true,
    },
    title: {
      type: String,
      required: [true, "Quote title is required"],
      trim: true,
      maxlength: [200, "Title cannot exceed 200 characters"],
    },
    description: {
      type: String,
      trim: true,
      maxlength: [1000, "Description cannot exceed 1000 characters"],
    },

    // Parties Involved
    customer: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Individual",
      required: [true, "Customer is required"],
    },
    serviceProvider: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "ServiceProvider",
      required: [true, "Service provider is required"],
    },

    // Vehicle Information
    vehicle: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Vehicle",
      required: [true, "Vehicle is required"],
    },
    vehicleDetails: {
      make: String,
      model: String,
      year: Number,
      variant: String,
      color: String,
      mileage: Number,
    },

    // Pricing Information
    pricing: {
      basePrice: {
        type: Number,
        required: [true, "Base price is required"],
        min: [0, "Base price cannot be negative"],
      },
      additionalCharges: [
        {
          description: String,
          amount: {
            type: Number,
            min: [0, "Additional charge cannot be negative"],
          },
        },
      ],
      discounts: [
        {
          description: String,
          amount: {
            type: Number,
            min: [0, "Discount cannot be negative"],
          },
        },
      ],
      totalPrice: {
        type: Number,
        required: [true, "Total price is required"],
        min: [0, "Total price cannot be negative"],
      },
      currency: {
        type: String,
        default: "USD",
        enum: ["USD", "EUR", "GBP", "SAR", "AED"],
      },
    },

    // Terms and Conditions
    terms: {
      validityPeriod: {
        type: Number,
        default: 30, // days
        min: [1, "Validity period must be at least 1 day"],
      },
      deliveryTime: {
        type: Number,
        default: 7, // days
        min: [1, "Delivery time must be at least 1 day"],
      },
      warranty: {
        type: String,
        trim: true,
      },
      conditions: [String],
    },

    // Quote Status
    status: {
      type: String,
      enum: ["draft", "sent", "viewed", "accepted", "rejected", "expired"],
      default: "draft",
    },

    // Response Information
    response: {
      customerResponse: {
        type: String,
        enum: ["pending", "accepted", "rejected", "counter_offer"],
        default: "pending",
      },
      customerNotes: String,
      respondedAt: Date,
    },

    // Counter Offer (if applicable)
    counterOffer: {
      isCounterOffer: {
        type: Boolean,
        default: false,
      },
      originalQuote: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Quote",
      },
      counterPrice: Number,
      counterTerms: String,
      counterNotes: String,
    },

    // Attachments
    attachments: [
      {
        name: String,
        url: String,
        type: String,
        uploadedAt: {
          type: Date,
          default: Date.now,
        },
      },
    ],

    // Communication
    messages: [
      {
        sender: {
          type: String,
          enum: ["customer", "service_provider"],
        },
        message: String,
        timestamp: {
          type: Date,
          default: Date.now,
        },
        attachments: [String], // URLs to attached files
      },
    ],

    // Expiration
    expiresAt: {
      type: Date,
      required: [true, "Expiration date is required"],
    },

    // Metadata
    tags: [String],
    priority: {
      type: String,
      enum: ["low", "medium", "high", "urgent"],
      default: "medium",
    },

    // Timestamps
    sentAt: Date,
    viewedAt: Date,
    respondedAt: Date,
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Indexes for better performance
quoteSchema.index({ quoteNumber: 1 });
quoteSchema.index({ customer: 1 });
quoteSchema.index({ serviceProvider: 1 });
quoteSchema.index({ vehicle: 1 });
quoteSchema.index({ status: 1 });
quoteSchema.index({ expiresAt: 1 });
quoteSchema.index({ createdAt: -1 });

// Virtual for formatted total price
quoteSchema.virtual("formattedTotalPrice").get(function () {
  return `${this.pricing.currency} ${this.pricing.totalPrice.toLocaleString()}`;
});

// Virtual for days until expiration
quoteSchema.virtual("daysUntilExpiration").get(function () {
  const now = new Date();
  const diffTime = this.expiresAt - now;
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
});

// Pre-save middleware
quoteSchema.pre("save", function (next) {
  // Always generate quote number
  if (!this.quoteNumber) {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 5);
    this.quoteNumber = `QT-${timestamp}-${random}`.toUpperCase();
  }

  // Set expiration date if not provided
  if (!this.expiresAt) {
    this.expiresAt = new Date(
      Date.now() + this.terms.validityPeriod * 24 * 60 * 60 * 1000
    );
  }

  // Calculate total price
  if (this.pricing.basePrice) {
    let total = this.pricing.basePrice;

    // Add additional charges
    if (this.pricing.additionalCharges) {
      total += this.pricing.additionalCharges.reduce(
        (sum, charge) => sum + charge.amount,
        0
      );
    }

    // Subtract discounts
    if (this.pricing.discounts) {
      total -= this.pricing.discounts.reduce(
        (sum, discount) => sum + discount.amount,
        0
      );
    }

    this.pricing.totalPrice = Math.max(0, total);
  }

  next();
});

// Static method to find active quotes
quoteSchema.statics.findActive = function () {
  return this.find({
    status: { $in: ["draft", "sent", "viewed"] },
    expiresAt: { $gt: new Date() },
  });
};

// Static method to find expired quotes
quoteSchema.statics.findExpired = function () {
  return this.find({
    status: { $in: ["sent", "viewed"] },
    expiresAt: { $lte: new Date() },
  });
};

// Instance method to mark as viewed
quoteSchema.methods.markAsViewed = function () {
  if (this.status === "sent") {
    this.status = "viewed";
    this.viewedAt = new Date();
    return this.save();
  }
  return Promise.resolve(this);
};

// Instance method to accept quote
quoteSchema.methods.acceptQuote = function (customerNotes = "") {
  this.status = "accepted";
  this.response.customerResponse = "accepted";
  this.response.customerNotes = customerNotes;
  this.response.respondedAt = new Date();
  return this.save();
};

// Instance method to reject quote
quoteSchema.methods.rejectQuote = function (customerNotes = "") {
  this.status = "rejected";
  this.response.customerResponse = "rejected";
  this.response.customerNotes = customerNotes;
  this.response.respondedAt = new Date();
  return this.save();
};

// Instance method to add message
quoteSchema.methods.addMessage = function (sender, message, attachments = []) {
  this.messages.push({
    sender,
    message,
    attachments,
    timestamp: new Date(),
  });
  return this.save();
};

export default mongoose.model("Quote", quoteSchema);
